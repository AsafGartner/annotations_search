<html>
<head>
<meta charset="UTF-8">
<title>Handmade Hero Search</title>
<style>
    body {
        background-color: #222;
        font-family: sans-serif;
        color: #ddd;
        overflow-y: scroll;
    }

    h2 {
        text-align: center;
    }

    #loadingContainer {
        position: fixed;
        top: 0;
        left: 0;
    }

    .queryContainer {
        width: 1000px;
        margin: 15px auto;
        display: flex;
        flex-direction: horizontal;
    }

    .queryContainer label {
        flex-grow: 0;
        flex-shrink: 0;
    }

    #query {
        flex-grow: 1;
    }

    #results {
        width: 800px;
        margin: 0 auto;
    }

    .dayContainer {
        background-color: #161616;
    }

    .dayContainer:nth-child(2n) {
        background-color: #303030;
    }

    .dayName {
        width: 200px;
        display: inline-block;
        vertical-align: top;
        color: #8A877D;
        font-size: 12px;
        line-height: 16px;
        box-sizing: border-box;
        padding: 5px;
    }

    .markerList {
        display: inline-block;
        width: 600px;
        box-sizing: border-box;
        vertical-align: top;
    }

    .marker {
        padding: 10px 5px;
        cursor: pointer;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        display: block;
        text-decoration: none;
        color: #ddd;
    }

    .marker:first-child {
        border: none;
    }

    .marker b {
        color: black;
        background-color: rgb(255, 155, 0);
    }

    .marker:hover {
        background-color: #444;
    }

    #resultsSummary {
        text-align: center;
        margin: 10px 0;
    }
</style>
</head>
<body>
<div id="loadingContainer">
    <span>Loading annotations:</span>
    <span id="loadingProgress">Getting list of files...</span>
    <br />
    <span>You can start typing. Results will stream in as soon as they are available.</span>
</div>
<h2>Handmade Hero Annotations Search</h2>
<div class="queryContainer">
    <label>Query:</label> <input type="text" id="query" autofocus></input>
</div>
<div id="resultsSummary"></div>
<div id="results">
</div>

<script>
if (location.hash && location.hash.length > 0) {
    var initialQuery = location.hash;
    if (initialQuery[0] == "#") {
        initialQuery = initialQuery.slice(1);
    }
    document.getElementById("query").value = decodeURIComponent(initialQuery);
}


var fileListsToLoad = 0;
var fileListsLoaded = 0;

var itemsToLoad = 0;
var itemsLoaded = 0;
var lastEpisodeIdxLoaded = -1;

var lastQuery = null;
var resultsToRender = [];
var resultsIndex = 0;
var resultsMarkerIndex = 0;
var resultsContainer = document.getElementById("results");
var rendering = false;

var dayContainerPrototype = document.createElement("DIV");
dayContainerPrototype.classList.add("dayContainer");

var dayNamePrototype = document.createElement("SPAN");
dayNamePrototype.classList.add("dayName");
dayContainerPrototype.appendChild(dayNamePrototype);

var markerListPrototype = document.createElement("DIV");
markerListPrototype.classList.add("markerList");
dayContainerPrototype.appendChild(markerListPrototype);

var markerPrototype = document.createElement("A");
markerPrototype.classList.add("marker");
markerPrototype.setAttribute("target", "_blank");

var highlightPrototype = document.createElement("B");

var fileList = [];

var episodes = [];

function getEpisodeName(filename) {
    // NOTE(agartner): Expected filename with extension
    var day = filename.slice(0, filename.indexOf("."));
    var dayParts = day.match(/([a-zA-Z_-]+)([0-9]+)?(_([0-9]+))?/);
    day = dayParts[1].slice(0, 1).toUpperCase() + dayParts[1].slice(1) + (dayParts[2] ? " " + dayParts[2] : "") + (dayParts[4] ? " Part " + dayParts[4] : "");
    return day;
}

function sortDays(dayA, dayB) {
    return dayB.localeCompare(dayA);
}

function fileListLoaded(data) {
    fileListsLoaded++;
    var files = [];
    for (var i = data.length-1; i >= 0; --i) {
        var file = data[i];
        files.push({
            name: file.name,
            day: getEpisodeName(file.name),
            path: "https://git.handmade.network/api/v4/projects/Annotation-Pushers%2FAnnotation-Game/repository/files/" + encodeURIComponent(file.path) + "?ref=master",
            data: null
        });
    }
    fileList = fileList.concat(files);
    if (fileListsLoaded == fileListsToLoad) {
        itemsToLoad = fileList.length;
        fileList = fileList.sort(function(a, b) {
            return sortDays(a.day, b.day);
        });
        for (var i = 0; i < fileList.length; ++i) {
            addFile(fileList[i].name, fileList[i].path, i);
        }
    }
}

function episodeFileLoaded(name, filepath, idx, contents) {
    itemsLoaded++;
    if (itemsLoaded == itemsToLoad) {
        document.getElementById("loadingContainer").style.display = "none";
    } else {
        document.getElementById("loadingProgress").textContent = itemsLoaded + "/" + itemsToLoad;
    }

    var day = getEpisodeName(name);
    var parsed = HMML_parse(contents);
    if (parsed.error){
        console.error("Failed to parse", name, parsed.error);
        fileList[idx].data = "failed";
        dataAtIdxReady(idx);
    } else {
        var title = parsed.metadata.title;
        var markers = [];
        for (var i = 0; i < parsed.annotations.length; ++i) {
            var current = parsed.annotations[i];
            var match = current.time.match(/((\d+):)?(\d+):(\d+)/);
            var totalTime = (match[2] ? parseInt(match[2], 10) : 0) * 60 * 60 + parseInt(match[3], 10) * 60 + parseInt(match[4], 10);
            var marker = {
                totalTime: totalTime,
                prettyTime: markerTime(totalTime),
                text: ((current.author && current.author.length > 0) ? current.author + ": " : "") + current.text
            }
            markers.push(marker);
        }
        fileList[idx].data = {
            day: day,
            title: title,
            markers: markers,
            filename: name.slice(0, name.indexOf(".")),
            filepath: filepath
        };

        dataAtIdxReady(idx);
    }
}

function episodeFileFailed(name, filepath, idx) {
    fileList[idx].data = "failed";
    dataAtIdxReady(idx);
}

function dataAtIdxReady(idx) {
    if (idx == lastEpisodeIdxLoaded + 1) {
        var i;
        for (i = idx; fileList[i] && fileList[i].data; ++i) {
            if (fileList[i].data != "failed") {
                episodes.push(fileList[i].data);
            }
            lastEpisodeIdxLoaded = i;
        }
        runSearch();
    }
}

function addFile(name, filepath, idx) {
    var xhr = new XMLHttpRequest();
    xhr.addEventListener("load", function() {
        var json = JSON.parse(xhr.response);
        if (json.error || json.message) {
            console.error("Failed to load episode: " + filepath);
            episodeFileLoaded(name, filepath, idx);
        } else {
            var base64 = json.content;
            var contents = atob(base64);
            episodeFileLoaded(name, filepath, idx, contents);
        }
    });
    xhr.addEventListener("error", function() {
        episodeFileFailed(name, filepath, idx);
    });
    xhr.open("GET", filepath);
    xhr.send();
}

function markerTime(totalTime) {
    var markTime = "(";
    var hours = Math.floor(totalTime / 60 / 60);
    var minutes = Math.floor(totalTime / 60) % 60;
    var seconds = totalTime % 60;
    if (hours > 0) {
        markTime += padTimeComponent(hours) + ":";
    }

    markTime += padTimeComponent(minutes) + ":" + padTimeComponent(seconds) + ")";

    return markTime;
}

function padTimeComponent(component) {
    return (component < 10 ? "0" + component : component);
}

function runSearch() {
    var queryStr = document.getElementById("query").value;
    if (lastQuery != queryStr) {
        var oldResultsContainer = resultsContainer;
        resultsContainer = oldResultsContainer.cloneNode(false);
        oldResultsContainer.parentNode.insertBefore(resultsContainer, oldResultsContainer);
        oldResultsContainer.remove();
        resultsIndex = 0;
        resultsMarkerIndex = 0;
    }
    lastQuery = queryStr;
    resultsToRender = [];
    var numEpisodes = 0;
    var numMarkers = 0;
    var totalSeconds = 0;
    if (queryStr && queryStr.length > 0) {
        var query = new RegExp(queryStr.replace("(", "\\(").replace(")", "\\)").replace(/(^|[^\\])\\$/, "$1"), "gi");
        for (var i = 0; i < episodes.length; ++i) {
            var episode = episodes[i];
            var matches = [];
            for (var j = 0; j < episode.markers.length; ++j) {
                query.lastIndex = 0;
                var result = query.exec(episode.markers[j].text);
                if (result && result[0].length > 0) {
                    numMarkers++;
                    matches.push(episode.markers[j]);
                    if (j < episode.markers.length-1) {
                        totalSeconds += episode.markers[j+1].totalTime - episode.markers[j].totalTime;
                    }
                }
            }
            if (matches.length > 0) {
                numEpisodes++;
                resultsToRender.push({
                    query: query,
                    episode: episode,
                    matches: matches
                });
            }
        }

        if (!rendering) {
            renderResults();
        }
    }

    var totalTime = Math.floor(totalSeconds/60/60) + "h " + Math.floor(totalSeconds/60)%60 + "m " + totalSeconds%60 + "s ";

    document.getElementById("resultsSummary").textContent = "Found: " + numEpisodes + " episodes, " + numMarkers + " markers, " + totalTime + "total.";
}

function renderMatches(renderStart) {
    var query = resultsToRender[resultsIndex].query;
    var episode = resultsToRender[resultsIndex].episode;
    var matches = resultsToRender[resultsIndex].matches;
    var markerList = null;
    if (resultsMarkerIndex == 0) {
        var dayContainer = dayContainerPrototype.cloneNode(true);
        var dayName = dayContainer.children[0];
        markerList = dayContainer.children[1];
        dayName.textContent = episode.day + ": " + episode.title;
        resultsContainer.appendChild(dayContainer);
    } else {
        markerList = document.querySelector("#results > .dayContainer:nth-child(" + (resultsIndex+1) + ") .markerList");
    }

    do {
        var match = matches[resultsMarkerIndex];
        var marker = markerPrototype.cloneNode();
        marker.setAttribute("href", "http://asafgartner.github.io/annotations_player/hmh.html#" + episode.filename + "#" + match.totalTime);
        query.lastIndex = 0;
        var cursor = 0;
        var text = match.text;
        var result = null;
        marker.appendChild(document.createTextNode(match.prettyTime + " "));
        while (result = query.exec(text)) {
            if (result.index > cursor) {
                marker.appendChild(document.createTextNode(text.slice(cursor, result.index)));
            }
            var highlightEl = highlightPrototype.cloneNode();
            highlightEl.textContent = result[0];
            marker.appendChild(highlightEl);
            cursor = result.index + result[0].length;
        }

        if (cursor < text.length) {
            marker.appendChild(document.createTextNode(text.slice(cursor, text.length)));
        }
        markerList.appendChild(marker);
        resultsMarkerIndex++;
    } while (resultsMarkerIndex < matches.length && performance.now() - renderStart < 1);

    return resultsMarkerIndex == matches.length;
}

function renderResults() {
    if (resultsIndex < resultsToRender.length) {
        rendering = true;
        var renderStart = performance.now();
        while (resultsIndex < resultsToRender.length && performance.now() - renderStart < 1) {
            var done = renderMatches(renderStart);
            if (done) {
                resultsMarkerIndex = 0;
                resultsIndex++;
            }
        }
        requestAnimationFrame(renderResults);
    } else {
        rendering = false;
    }
}

fileListsToLoad = 1;

function loadFileList(page, callback) {
    var xhr = new XMLHttpRequest();
    xhr.addEventListener("load", function() {
            callback(page, xhr);
    });
    xhr.addEventListener("error", function() {
            callback(page, xhr);
    });
    xhr.open("GET", "https://git.handmade.network/api/v4/projects/Annotation-Pushers%2FAnnotation-Game/repository/tree?per_page=100&page=" + page + "&path=projects%2Fmiotatsu%2Friscy");
    xhr.send();
}

function rawFileListLoaded(page, xhr) {
    var data = null;
    if (xhr.status == 200) {
        var json = JSON.parse(xhr.response);
        if (!json.error && !json.message) {
            data = json;
        }
    }
    if (!data) {
        console.error("Failed to load file list. Page: " + page);
    }
    fileListLoaded(data || []);
}

loadFileList(1, function(page, xhr) {
    var data = null;
    if (xhr.status == 200) {
        var json = JSON.parse(xhr.response);
        if (!json.error && !json.message) {
            var numPages = parseInt(xhr.getResponseHeader("X-Total-Pages"), 10);
            fileListsToLoad = numPages;
            for (var i = 2; i <= numPages; ++i) {
                loadFileList(i, rawFileListLoaded);
            }
            data = json;
        }
    }
    if (!data) {
        console.error("Failed to load file list. Page: " + page);
    }
    fileListLoaded(data || []);
});


var queryEl = document.getElementById("query")
queryEl.addEventListener("input", function(ev) {
    history.replaceState(null, null, "#" + encodeURIComponent(queryEl.value));
    runSearch();
});

runSearch();



function HMML_parse(contents) {
    var l = new HMMLexer();
    var state = {
        line: 0,
        annos: [],
        meta: {
            member: "",
            twitch: "",
            project: "",
            title: "",
            platform: "",
            id: "",
            annotator: ""
        },
        an: {
            line: 0,
            time: "",
            text: "",
            author: "",
            references: [],
            markers: [],
            quote: {
                id: 0,
                author: ""
            },
            is_quote: false
        },
        ref: {
            site: "",
            page: "",
            url: "",
            title: "",
            article: "",
            author: "",
            editor: "",
            publisher: "",
            isbn: "",
            offset: 0
        },
        attr: "",
        mnext: 0,
        first: true
    };
    l.setInput(contents, state);

    try {
        var r;
        do {
            r = l.next();
        } while (!r);
        state.annos.forEach(function(a) {
            if (!a.is_quote) {
                delete a.quote;
            }
            if (a.author === "") delete a.author;
            delete a.is_quote;
        });
        return {
            metadata: state.meta,
            annotations: state.annos
        };
    } catch (e) {
        return {
            error: e
        };
    }
}

function HMMLexer() {}
/* generated by jison-lex 0.3.4 */
HMMLexer.prototype = {

    EOF: 1,

    parseError: function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

    // resets the lexer, sets new input
    setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
    },

    // consumes and returns one char from the input
    input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

    // unshifts one char (or a string) into the input
    unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0) +
                oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

    // When called from action, caches matched text and appends it on next action
    more: function() {
        this._more = true;
        return this;
    },

    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject: function() {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

    // retain first n characters of the match
    less: function(n) {
        this.unput(this.match.slice(n));
    },

    // displays already matched input, i.e. for error messages
    pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
    },

    // displays upcoming input, i.e. for error messages
    upcomingInput: function() {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

    // displays the character position where the lexing error occurred, i.e. for error messages
    showPosition: function() {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

    // test the lexed token: return FALSE when not a match, otherwise return token
    test_match: function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

    // return next match in input
    next: function() {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

    // return next match that has a token
    lex: function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    begin: function begin(condition) {
        this.conditionStack.push(condition);
    },

    // pop the previously active lexer condition state off the condition stack
    popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

    // produce the lexer rule set which is active for the currently active lexer condition state
    _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

    // alias for begin(condition)
    pushState: function pushState(condition) {
        this.begin(condition);
    },

    // return the number of states currently on the stack
    stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
    },
    options: {
        "moduleName": "temp"
    },
    performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        function ERR(yy, err) {
            console.log("hmmlib error: L%d: %s\n", yy.line, err);
            throw {
                message: err,
                line: yy.line
            };
        }

        function CHECKESCAPE(yy, str) {
            if ("[]:@~\\\"".indexOf(str) == -1) {
                ERR(yy, "hmmlib: Unknown backslash escape code: %s", str);
            }
        }

        function UNQUOTE(yy, str) {
            var i = 0;
            var j = 0;
            while ((j = str.indexOf('\\', i)) != -1) {
                CHECKESCAPE(yy, str.charAt(j));
                str = str.slice(i, j) + str.slice(j + 1);
                i = j + 1;
            }
            return str;
        }

        function M_(yy, str, s) {
            yy.an.markers.push({
                type: str
            });
            yy.mnext = s;
        }

        function M_ADD(yy, t, n) {
            yy.an.markers[yy.an.markers.length - 1].marker = t.substr(0, n);
            yy.an.markers[yy.an.markers.length - 1].offset = yy.an.text.length;
            if (yy.mnext === "TEXT") {
                yy.an.text += t.substr(0, n);
            }
        }

        function MX_ADD(yy, c) {
            var m = yy.an.markers[yy.an.markers.length - 1];
            if (m.parameter) {
                m.parameter += c;
            } else {
                m.parameter = c;
            }
            yy.an.text += c;
        }

        function NEWANNO(yy) {
            if (!yy.first) yy.annos.push(yy.an);
            yy.an = {
                line: yy.line,
                time: "",
                text: "",
                author: "",
                references: [],
                markers: [],
                quote: {
                    id: 0,
                    author: ""
                },
                is_quote: false
            };
            yy.an.line = yy.line;
            yy.first = false;
        }

        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
            case 0:
                ERR(yy, "Unexpected EOF, video close tag not found.");
                break;
            case 1:
                yy.line++;
                break;
            case 2:
                yy_.begin("VIDEO");
                break;
            case 3:
                ERR(yy, "Missing video tag.");
                break;
            case 4:
                break;
            case 5:
                yy.attr = "member";
                yy_.begin("V_ATTR");
                break;
            case 6:
                yy.attr = "twitch";
                yy_.begin("V_ATTR");
                break;
            case 7:
                yy.attr = "project";
                yy_.begin("V_ATTR");
                break;
            case 8:
                yy.attr = "title";
                yy_.begin("V_ATTR");
                break;
            case 9:
                yy.attr = "platform";
                yy_.begin("V_ATTR");
                break;
            case 10:
                yy.attr = "id";
                yy_.begin("V_ATTR");
                break;
            case 11:
                yy.attr = "annotator";
                yy_.begin("V_ATTR");
                break;
            case 12:
                yy_.begin("ANNOTATION");
                break;
            case 13:
                ERR(yy, "Invalid char '" + yy_.yytext + "' in video tag.");
                break;
            case 14:
                yy_.begin("VIDEO");
                break;
            case 15:
                yy.meta[yy.attr] = yy_.yytext;
                yy_.begin("VIDEO");
                break;
            case 16:
                yy.meta[yy.attr] = UNQUOTE(yy, yy_.yytext.substr(1, yy_.yyleng - 2));
                yy_.begin("VIDEO");
                break;
            case 17:
                yy_.less(0);
                yy_.begin("VIDEO");
                break;
            case 18:
                NEWANNO(yy);
                return 1;
                break;
            case 19:
                NEWANNO(yy);
                yy.an.time = yy_.yytext.substr(1, yy_.yyleng - 4);
                yy_.begin("AUTHOR");
                break;
            case 20:
                NEWANNO(yy);
                yy.an.time = yy_.yytext.substr(1, yy_.yyleng - 2);
                yy_.begin("TEXT_START");
                break;
            case 21:
                ERR(yy, "Timecode '" + yy_.yytext + "' out of range.");
                break;
            case 22:
                break;
            case 23:
                ERR(yy, "Cannot parse annotation. Expected timecode.");
                break;
            case 24:
                M_(yy, "CATEGORY", "TEXT");
                yy_.begin("MARKER");
                break;
            case 25:
                M_(yy, "MEMBER", "TEXT");
                yy_.begin("MARKER");
                break;
            case 26:
                M_(yy, "PROJECT", "TEXT");
                yy_.begin("MARKER");
                break;
            case 27:
                yy_.less(0);
                yy_.begin("TEXT");
                break;
            case 28:
                ERR(yy, "Unknown character '" + yy_.yytext + "' after timecode.");
                break;
            case 29:
                yy.an.text += yy_.yytext;
                break;
            case 30:
                CHECKESCAPE(yy, yy_.yytext.charAt(1));
                yy.an.text += yy_.yytext.substr(1, yy_.yyleng - 1);
                break;
            case 31:
                yy.an.text += ' ';
                M_(yy, "CATEGORY", "TEXT");
                yy_.begin("MARKER");
                break;
            case 32:
                yy.an.text += ' ';
                M_(yy, "MEMBER", "TEXT");
                yy_.begin("MARKER");
                break;
            case 33:
                yy.an.text += ' ';
                M_(yy, "PROJECT", "TEXT");
                yy_.begin("MARKER");
                break;
            case 34:
                M_(yy, "CATEGORY", "MARKER_XTRA");
                yy_.begin("MARKER");
                break;
            case 35:
                M_(yy, "MEMBER", "MARKER_XTRA");
                yy_.begin("MARKER");
                break;
            case 36:
                M_(yy, "PROJECT", "MARKER_XTRA");
                yy_.begin("MARKER");
                break;
            case 37:
                yy_.begin("AFTERTEXT");
                break;
            case 38:
                yy.ref.offset = yy.an.text.length;
                yy_.begin("REF");
                break;
            case 39:
                break;
            case 40:
                yy.an.text += ' ';
                break;
            case 41:
                yy.an.text += yy_.yytext;
                break;
            case 42:
                M_ADD(yy, yy_.yytext);
                yy_.begin(yy.mnext);
                break;
            case 43:
                M_ADD(yy, yy_.yytext.substr(1, yy_.yyleng - 2));
                yy_.begin(yy.mnext);
                break;
            case 44:
                ERR(yy, "Cannot parse Marker. Expected quoted or alphanumeric attribute.");
                break;
            case 45:
                MX_ADD(yy, ']');
                break;
            case 46:
                yy_.begin("TEXT");
                break;
            case 47:
                if (yy.an.markers[yy.an.markers.length - 1].parameter) {
                    MX_ADD(yy, ' ');
                }
                break;
            case 48:
                MX_ADD(yy, yy_.yytext);
                break;
            case 49:
                break;
            case 50:
                yy.attr = "site";
                yy_.begin("R_ATTR");
                break;
            case 51:
                yy.attr = "page";
                yy_.begin("R_ATTR");
                break;
            case 52:
                yy.attr = "url";
                yy_.begin("R_ATTR");
                break;
            case 53:
                yy.attr = "title";
                yy_.begin("R_ATTR");
                break;
            case 54:
                yy.attr = "article";
                yy_.begin("R_ATTR");
                break;
            case 55:
                yy.attr = "author";
                yy_.begin("R_ATTR");
                break;
            case 56:
                yy.attr = "editor";
                yy_.begin("R_ATTR");
                break;
            case 57:
                yy.attr = "publisher";
                yy_.begin("R_ATTR");
                break;
            case 58:
                yy.attr = "isbn";
                yy_.begin("R_ATTR");
                break;
            case 59:
                yy.an.references.push(yy.ref);
                yy.ref = {};
                yy_.begin("TEXT");
                break;
            case 60:
                ERR(yy, "Unexpected item in ref: " + yy_.yytext);
                break;
            case 61:
                break;
            case 62:
                yy.ref[yy.attr] = yy_.yytext;
                yy_.begin("REF");
                break;
            case 63:
                yy.ref[yy.attr] = UNQUOTE(yy, yy_.yytext.substr(1, yy_.yyleng - 2));
                yy_.begin("REF");
                break;
            case 64:
                NEWANNO(yy);
                return 1;
                break;
            case 65:
                break;
            case 66:
                yy_.begin("QUOTES");
                break;
            case 67:
                yy_.begin("CATEGORIES");
                yy_.less(1);
                break;
            case 68:
                yy_.begin("ANNOTATION");
                yy_.less(0);
                break;
            case 69:
                ERR(yy, "Unexpected thing after text node: " + yy_.yytext);
                break;
            case 70:
                ERR(yy, "Unexpected thing after text node: " + yy_.yytext);
                break;
            case 71:
                yy.an.author = yy_.yytext.substr(0, yy_.yyleng - 1);
                yy_.begin("TEXT_START");
                break;
            case 72:
                break;
            case 73:
                break;
            case 74:
                yy.an.markers.push({
                    type: "CATEGORY",
                    marker: yy_.yytext.substr(1, yy_.yyleng - 1),
                    offset: -1
                });
                break;
            case 75:
                yy.an.markers.push({
                    type: "CATEGORY",
                    marker: UNQUOTE(yy, yy_.yytext.substr(2, yy_.yyleng - 3)),
                    offset: -1
                });
                break;
            case 76:
                yy_.begin("QUOTES");
                break;
            case 77:
                yy_.begin("ANNOTATION");
                break;
            case 78:
                ERR(yy, "Unexpected character in category tag: " + yy_.yytext);
                break;
            case 79:
                break;
            case 80:
                yy.an.is_quote = true;
                yy.an.quote.id = parseInt(yy_.yytext);
                yy_.begin("ANNOTATION");
                break;
            case 81:
                yy.an.quote.author += yy_.yytext;
                break;
            case 82:
                ERR(yy, "Unexpected character in quotes tag: " + yy_.yytext);
                break;
        }
    },
    rules: [/^(?:$)/, /^(?:\r\n|\n)/, /^(?:(\[video\b))/, /^(?:.)/, /^(?:([\t \r]+))/, /^(?:member([\t \r]*)=)/, /^(?:twitch_username([\t \r]*)=)/, /^(?:project([\t \r]*)=)/, /^(?:title([\t \r]*)=)/, /^(?:platform([\t \r]*)=)/, /^(?:id([\t \r]*)=)/, /^(?:annotator([\t \r]*)=)/, /^(?:\])/, /^(?:.)/, /^(?:([\t \r]+))/, /^(?:([^\" \]\t\r\n][^ \]\t\r\n]*))/, /^(?:("([^\n\"\\]|\\.)*"))/, /^(?:\])/, /^(?:\[\/video\])/, /^(?:(\[[0-9]{1,2}(:[0-5][0-9]){1,2}\])(\[)@)/, /^(?:(\[[0-9]{1,2}(:[0-5][0-9]){1,2}\]))/, /^(?:(\[[0-9]{1,2}(:[6-9][0-9]){1,2}\]))/, /^(?:([\t \r]+))/, /^(?:.)/, /^(?:(\[):)/, /^(?:(\[)@)/, /^(?:(\[)~)/, /^(?:(\[))/, /^(?:.)/, /^(?:([^\\\:\@\~\[\]\r\n\t ])+)/, /^(?:\\.)/, /^(?:[ \r\t]+:)/, /^(?:[ \r\t]+@)/, /^(?:[ \r\t]+~)/, /^(?:(\[):)/, /^(?:(\[)@)/, /^(?:(\[)~)/, /^(?:\])/, /^(?:(\[)ref\b)/, /^(?:(\[))/, /^(?:([\t \r]+))/, /^(?:.)/, /^(?:([0-9a-zA-Z][0-9a-zA-Z_]*))/, /^(?:("([^\n\"\\]|\\.)*"))/, /^(?:.)/, /^(?:\\)/, /^(?:\])/, /^(?:[ ])/, /^(?:.)/, /^(?:([\t \r]+))/, /^(?:site([\t \r]*)=)/, /^(?:page([\t \r]*)=)/, /^(?:url([\t \r]*)=)/, /^(?:title([\t \r]*)=)/, /^(?:article([\t \r]*)=)/, /^(?:author([\t \r]*)=)/, /^(?:editor([\t \r]*)=)/, /^(?:publisher([\t \r]*)=)/, /^(?:isbn([\t \r]*)=)/, /^(?:\])/, /^(?:.)/, /^(?:([\t \r]+))/, /^(?:([^\" \]\t\r\n][^ \]\t\r\n]*))/, /^(?:("([^\n\"\\]|\\.)*"))/, /^(?:\[\/video\])/, /^(?:([\t \r]+))/, /^(?:(\[)quote\b)/, /^(?:(\[):)/, /^(?:(\[)[0-9])/, /^(?:..)/, /^(?:.)/, /^(?:[^\]\n]+\])/, /^(?:([\t \r]+))/, /^(?:([\t \r]+))/, /^(?::([^\" \]\t\r\n][^ \]\t\r\n]*))/, /^(?::("([^\n\"\\]|\\.)*"))/, /^(?:\](\[))/, /^(?:\])/, /^(?:.)/, /^(?:([\t \r]+))/, /^(?:[0-9]+([\t \r]*)\])/, /^(?:([0-9a-zA-Z][0-9a-zA-Z_]*))/, /^(?:.)/],
    conditions: {
        "QUOTES": {
            "rules": [0, 1, 79, 80, 81, 82],
            "inclusive": true
        },
        "CATEGORIES": {
            "rules": [0, 1, 73, 74, 75, 76, 77, 78],
            "inclusive": true
        },
        "AUTHOR": {
            "rules": [0, 1, 71, 72],
            "inclusive": true
        },
        "AFTERTEXT": {
            "rules": [0, 1, 64, 65, 66, 67, 68, 69, 70],
            "inclusive": true
        },
        "R_ATTR": {
            "rules": [0, 1, 61, 62, 63],
            "inclusive": true
        },
        "REF": {
            "rules": [0, 1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60],
            "inclusive": true
        },
        "MARKER_XTRA": {
            "rules": [0, 1, 45, 46, 47, 48],
            "inclusive": true
        },
        "MARKER": {
            "rules": [0, 1, 42, 43, 44],
            "inclusive": true
        },
        "TEXT": {
            "rules": [0, 1, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41],
            "inclusive": true
        },
        "TEXT_START": {
            "rules": [0, 1, 24, 25, 26, 27, 28],
            "inclusive": true
        },
        "ANNOTATION": {
            "rules": [0, 1, 18, 19, 20, 21, 22, 23],
            "inclusive": true
        },
        "V_ATTR": {
            "rules": [0, 1, 14, 15, 16, 17],
            "inclusive": true
        },
        "VIDEO": {
            "rules": [0, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
            "inclusive": true
        },
        "INITIAL": {
            "rules": [0, 1, 2, 3],
            "inclusive": true
        }
    }
}
</script>
</body>
</html>

